// gdat_to_ld.c
//  This program will take in a gdat file generated by the DLM and
//  convert it to a .ld file that can be read in I2. Data that comes
//  out will not match exactly as gdat stores data with a timestamp
//  attached and does not need to be a consistant frequency, but I2
//  data does need to be

#include "gdat_to_ld.h"
#include "ld_writing.h"
#include "../../gophercan-lib/GopherCAN_names.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <float.h>
#include <math.h>


// define everything that is neede in static memory
START_OF_FILE_t sof_data = {0};
FILE_METADATA_t file_data = {0};

const char session_def[] = "F1 Summer Testing";
const char short_comment_def[] = "Tyler breaking something again";
const char event_name_def[] = "Monaco Grand Prix";
const char long_comment_def[] = "What the fuck did you just fucking say about me, you little bitch? I'll have you know I graduated top of my class in the Navy Seals, and I've been involved in numerous secret raids on Al-Quaeda, and I have over 300 confirmed kills. I am trained in gorilla warfare and I'm the top sniper in the entire US armed forces. You are nothing to me but just another target. I will wipe you the fuck out with precision the likes of which has never been seen before on this Earth, mark my fucking words.";
const char location_def[] = "Spa";

// the head node WILL NOT be written in memory so it do not count it
CHANNEL_DESC_LL_NODE_t channel_head = 
{
    .channel_desc = {0},
    .location_fptr = 0,
    .data_buffer = NULL,
    .prev = NULL,
    .next = NULL,
};

GDAT_CHANNEL_LL_NODE_t gdat_data_head = 
{
    .channel = {0},
    .next = NULL
};


int main(int argc, char** argv)
{
    char* in_filename; // will be argv[1]
    char out_filename[MAX_FILENAME_SIZE];
    FILE* in_file;

    // check to make sure a filename was inputted. If so create the output
    // filname based on it
    if (argc <= 1)
    {
        printf("Usage: ./ld_converter <input file>\n");
        return -1;
    }

    in_filename = argv[1];
    strncpy(out_filename, in_filename, MAX_FILENAME_SIZE);
    strcat(out_filename, ".ld");

    // open the input file
    in_file = fopen(in_filename, "r");
    if (!in_file)
    {
        printf("Failed to open file: %s\n", in_filename);
        return -1;
    }
    
    // fill in all of the names and metadata for the ld file. This includes the
    // date and time from the gdat file, as well as event name, session, comments,
    // and location
    printf("Getting the metadata...\n");
    if (build_ld_file_metadata(in_file, &sof_data, &file_data)) return -1;

    // read in the gdat file and store all the data in ram with some linked
    // lists for all of the data nodes
    printf("Importing data from the file...\n");
    if (import_gdat(in_file, &gdat_data_head));

    fclose(in_file);

    /*
    // DEBUG print all of the channels
    GDAT_CHANNEL_LL_NODE_t* curr_node = gdat_data_head.next;
    while (curr_node != NULL)
    {
        printf("Channel: %u\n", curr_node->channel.gcan_id);
        U32* ts = curr_node->channel.timestamps;
        float* data = curr_node->channel.data_points;
        while(ts - curr_node->channel.timestamps < curr_node->channel.num_data_points)
        {
            printf("\t%u\t%f\n", *ts, *data);
            ts++;
            data++;
        }
        curr_node = curr_node->next;
    }
    */

    // take the data from gdat and use it to fill in all of the ld data headers
    // and data buffers. This will not fill in the file pointers yet. Do some
    // fancy math to figure out what the offset, scaler, divisor, and base10_shift
    // should be. Also find the logging frequency and give stats about the channel
    printf("Converting data to ld file format...\n");
    if (build_ld_data_channels(&gdat_data_head, &channel_head, true));

    // Run the "linker". This will fill out correct file space for all of the different
    // blocks of data and makes sure they will be correctly pointed to in the file
    printf("Linking file pointers...\n");
    if (link_id_file(&sof_data, &file_data, &channel_head)) return -1;

    // Open a new file with the correct name and begin writing all of the data to it.
    // Layout the file as planned after the linker was run
    printf("Writing ld data...\n");
    if (write_id_file(&sof_data, &file_data, &channel_head, out_filename)) return -1;

    printf("Conversion sucessful\n");
}


// build_ld_file_metadata
//  Function to open the input file, read the date and time, and ask the 
//  user for some metadata. Store all of this and add it the the ld file
//  we are working with
S8 build_ld_file_metadata(FILE* file, START_OF_FILE_t* sof, FILE_METADATA_t* metadat)
{
    U16 year;
    U8 month, day, hour, min, sec;
    U32 date_int = 0;
    U32 time_int = 0;
    char* char_ptr;
    char temp_char[MAX_STR_SIZE];
    char session[MAX_STR_SIZE];
    char short_comment[MAX_STR_SIZE] ;
    char team_name[] = "UofM FSAE";
    char event_name[MAX_STR_SIZE];
    char long_comment[STR_LEN_LONG];
    char location[MAX_STR_SIZE];

    // get the time things from the file. Get the integer number and parse
    // from there
    if (fscanf(file, "/dlm_data_%u_%u", &date_int, &time_int) == 0)
    {
        printf("Failed to get the metadata\n");
        return -1;
    }
    // ints are in base10 format YYYYMMDD and HHMMSS
    year = date_int / 10000;
    month = (date_int / 100) % 100;
    day = date_int % 100;
    hour = time_int / 10000;
    min = (time_int / 100) % 100;
    sec = time_int % 100;

    // ask for the other metadata things, most improtant first
    printf("Fill int the following fields:\n");
    printf("Venue: ");
    fgets(location, sizeof(location), stdin);
    printf("Event: ");
    fgets(event_name, sizeof(event_name), stdin);
    printf("Short Comment: ");
    fgets(short_comment, sizeof(short_comment), stdin);
    printf("Long Comment: ");
    fgets(long_comment, sizeof(long_comment), stdin);
    printf("Session: ");
    fgets(session, sizeof(session), stdin);

    // remove the extra shit at the end
    cutoff_string(location, MAX_STR_SIZE);
    cutoff_string(event_name, MAX_STR_SIZE);
    cutoff_string(short_comment, MAX_STR_SIZE);
    cutoff_string(long_comment, STR_LEN_LONG);
    cutoff_string(session, MAX_STR_SIZE);

    // check to make sure none of the strings are empty
    if (strlen(location) == 0) strncpy(location, location_def, MAX_STR_SIZE);
    if (strlen(event_name) == 0) strncpy(event_name, event_name_def, MAX_STR_SIZE);
    if (strlen(short_comment) == 0) strncpy(short_comment, short_comment_def, MAX_STR_SIZE);
    if (strlen(long_comment) == 0) strncpy(long_comment, long_comment_def, STR_LEN_LONG);
    if (strlen(session) == 0) strncpy(session, session_def, MAX_STR_SIZE);

    if (init_sof_block(sof, year, month, day, hour, min, sec, session, short_comment, team_name) ||
        init_metadata_block(metadat, event_name, session, long_comment, location))
    {
        printf("Failed to init metadata\n");
        return -1;
    }

    return 0;
}


// import_gdat
//  import the data in the gdat file. This will be stored as timestamped
//  data nodes for now, and will be converted to evenly spaced samples later. This
//  will ensure the data is in order when it is done
S8 import_gdat(FILE* file, GDAT_CHANNEL_LL_NODE_t* head)
{
    unsigned char datapoint[TOTAL_SIZE] = {0};
    U16 param = 0;
    U32 timestamp = 0;
    DPF_CONVERTER data;
    GDAT_CHANNEL_LL_NODE_t* curr_node = head->next;
    char temp_str[MAX_STR_SIZE] = "";

    data.u64 = 0;

    // place the file pointer in the correct spot (second line)
    fseek(file, 0, SEEK_SET);
    if (fgets(temp_str, MAX_STR_SIZE, file) == 0)
    {
        printf("Failed a read\n");
        return -1;
    }

    // take in the data point by point
    while (fread(datapoint, TOTAL_SIZE, sizeof(char), file))
    {
        // reset the integers
        param = 0;
        timestamp = 0;
        data.u64 = 0;

        // get the param_id
        param |= ((U16)(datapoint[1]));
        param |= ((U16)(datapoint[0]) << 8);

        // get the timestamp
        timestamp |= ((U32)(datapoint[5]));
        timestamp |= ((U32)(datapoint[4]) << (8*1));
        timestamp |= ((U32)(datapoint[3]) << (8*2));
        timestamp |= ((U32)(datapoint[2]) << (8*3));

        // get the datapoint
        data.u64 |= ((U64)(datapoint[13]));
        data.u64 |= ((U64)(datapoint[12]) << (8*1));
        data.u64 |= ((U64)(datapoint[11]) << (8*2));
        data.u64 |= ((U64)(datapoint[10]) << (8*3));
        data.u64 |= ((U64)(datapoint[9]) << (8*4));
        data.u64 |= ((U64)(datapoint[8]) << (8*5));
        data.u64 |= ((U64)(datapoint[7]) << (8*6));
        data.u64 |= ((U64)(datapoint[6]) << (8*7));

        // find the correct parameter in the LL by the ID
        curr_node = head->next;
        while (curr_node != NULL)
        {
            if (curr_node->channel.gcan_id == param)
            {
                break;
            }

            curr_node = curr_node->next;
        }

        // if the correct param was not found, make a new node with this ID
        if (curr_node == NULL)
        {
            curr_node = (GDAT_CHANNEL_LL_NODE_t*)malloc(sizeof(GDAT_CHANNEL_LL_NODE_t));
            if (!curr_node)
            {
                printf("Failed a malloc\n");
                return -1;
            }

            curr_node->next = head->next;
            head->next = curr_node;

            curr_node->channel.gcan_id = param;
            curr_node->channel.num_data_points = 0;
            curr_node->channel.array_size = STARTING_NUM_POINTS;

            // give the starting amount of memory for the data arrays
            curr_node->channel.timestamps = (U32*)malloc(STARTING_NUM_POINTS*sizeof(U32));
            curr_node->channel.data_points = (float*)malloc(STARTING_NUM_POINTS*sizeof(float));
            if (!curr_node->channel.timestamps || !curr_node->channel.data_points)
            {
                printf("Failed a malloc\n");
                return -1;
            }
        }

        // if the array is not big enough to handle this
        if (curr_node->channel.num_data_points == curr_node->channel.array_size)
        {
            curr_node->channel.array_size = curr_node->channel.array_size * 2;
            curr_node->channel.timestamps = (U32*)realloc(curr_node->channel.timestamps,
                                                          curr_node->channel.array_size * sizeof(U32));
            curr_node->channel.data_points = (float*)realloc(curr_node->channel.data_points,
                                                             curr_node->channel.array_size * sizeof(float));

            if (!curr_node->channel.timestamps || !curr_node->channel.data_points)
            {
                printf("Failed a realloc\n");
                return -1;
            }
        }

        // inset the node into the correct spot into the array based on the timestamp
        U32* curr_ts = curr_node->channel.timestamps + curr_node->channel.num_data_points; // start at the end + 1
        float* curr_dat = curr_node->channel.data_points + curr_node->channel.num_data_points;
        while (curr_ts > curr_node->channel.timestamps && timestamp <= *(curr_ts - 1))
        {
            // the timestamp arrays must move down
            *curr_ts = *(curr_ts - 1);
            *curr_dat = *(curr_dat - 1);

            curr_ts--;
            curr_dat--;
        }

        *curr_ts = timestamp;
        *curr_dat = (float)data.d;

        curr_node->channel.num_data_points++;
    }

    return 0;
}


// build_ld_data_channels
//  take all of the gdat data and create ld channels, also adding the data
//  to buffers with interpolation to match the ld format better. When this
//  conversion happens, print out logging data for the channels
S8 build_ld_data_channels(GDAT_CHANNEL_LL_NODE_t* gdat_head, CHANNEL_DESC_LL_NODE_t* ld_head,
                          bool print_chan_stats)
{
    GDAT_CHANNEL_LL_NODE_t* curr_gdat = gdat_head->next;
    U32 min_time_delta = UINT32_MAX;
    U32 max_time_delta = 0;
    U32 max_time = 0;
    U32 frequency_hz = 0;
    float data_min = FLT_MAX;
    float data_max = FLT_MIN;

    float scaler_float;
    S16 offset_s16;
    S16 scaler_s16;
    S16 divisor_s16;
    S16 base10_shift_s16;

    U32* ld_buf;
    U32 ld_data_points;

    // the channel cant hold strings this long, but strncpy will append
    char chan_name[MAX_STR_SIZE];
    char name_shrt[MAX_STR_SIZE];
    char chan_unit[MAX_STR_SIZE];

    while (curr_gdat != NULL)
    {
        U32* curr_ts = curr_gdat->channel.timestamps;
        float* curr_data = curr_gdat->channel.data_points;
        max_time = 0;
        min_time_delta = UINT32_MAX;
        max_time_delta = 0;
        data_min = FLT_MAX;
        data_max = FLT_MIN;

        // calculate the minimum and maximum of the channel and scale it correctly to a U32
        // with scaling to match the ld format. Also calculate the minimum time between points
        // that is not 0, this will be used for the frequency. Log the maximum time delta for
        // debugging reasons
        while (curr_ts - curr_gdat->channel.timestamps < curr_gdat->channel.num_data_points)
        {
            if (*curr_data > data_max) data_max = *curr_data;
            if (*curr_data < data_min) data_min = *curr_data;

            // ignore the first datapoint for time delta calculation
            U32 this_delta;
            if (curr_ts != curr_gdat->channel.timestamps)
            {
                this_delta = *curr_ts - *(curr_ts - 1);
                if (this_delta > max_time_delta) max_time_delta = this_delta;
                if (this_delta < min_time_delta && this_delta > 0) min_time_delta = this_delta; // ignore deltas of 0, these shouldnt exist so it could be a bug
            }

            curr_ts++;
            curr_data++;
        }
        max_time = *(curr_ts - 1);

        // limit the freq to 1 - 1000. If the data is less complete than this (in reality logging
        // the freq is less than 1Hz), just interpolate it in because it probably does not matter
        frequency_hz = 1000 / (min_time_delta);
        frequency_hz = MIN(frequency_hz, 1000);
        frequency_hz = MAX(frequency_hz, 1);

        // get good scalers for this data. This is acomplished by first scaling the data to 8*10^x
        // (0.008, 0.8, 80, 8000, ect) base on what is closest, then get a good *10^x exponent to
        // scale the data to 8000000 (approx 2^23, the size of float mantissa). This should garuntee
        // precision is kept as long as the numbers are not too large
        float scaling_value = MAX(fabs(data_max), fabs(data_min)); // scale using the largest ABS

        S16 exp;
        bool done = false;
        for (exp = -37; exp < 37 && !done; exp++)
        {
            // see if 8*10^exp is the right representation
            if (scaling_value >= 8.0*pow(10, exp) && scaling_value < 8.0*pow(10, exp+1))
            {
                // if it is, find the scaler to get the data from a range maxing at 8*10^exp
                scaler_float = (8.0*pow(10, exp)) / (scaling_value);

                // set the base10 shifter to range the data to a max of 8*10^6 (approx 2^23)
                base10_shift_s16 = (6 - exp);
                done = true;
            }
        }
        if (!done)
        {
            printf("Param %u has data that cannot be represented\n", curr_gdat->channel.gcan_id);
            curr_gdat = curr_gdat->next;
            continue;
        }

        // take the float scaler and turn it into a fraction (s16/s16). It is ok if the fraction
        // is not perfect, data will still be correct but with slightly less accuracy
        offset_s16 = 0;
        convert_float_to_frac(scaler_float, &scaler_s16, &divisor_s16);

        // create a new buffer with enought points to fill between time=0 to time=max
        // at a frequency that is close to the max frequency the data was logged
        ld_data_points = curr_gdat->channel.timestamps[curr_gdat->channel.num_data_points - 1] / min_time_delta;
        ld_buf = (U32*)malloc(sizeof(U32) * ld_data_points);
        if (!ld_buf)
        {
            printf("Malloc failed\n");
            return -1;
        }

        divisor_s16 >>= 4;
        scaler_s16 >>= 4;

        // fill each of the points of the new data buffer, using linear interpolation
        // when the time point does not exacly exist. Also use the offset and scaler
        // to convert the floating point data to an int32
        U32 rolling_ts = 0;
        U32* curr_ld_buf = ld_buf;
        curr_ts = curr_gdat->channel.timestamps;
        curr_data = curr_gdat->channel.data_points;
        while (curr_ld_buf - ld_buf < ld_data_points)
        {
            if (curr_ts == curr_gdat->channel.timestamps)
            {
                // before the fisrt timestamp
                if (rolling_ts > *curr_ts)
                {
                    // we are past the first timestamp. Move on by running the loop again
                    // without increasing the rolling timestamp
                    curr_ts++;
                    curr_data++;
                }
                else
                {
                    // we are before the first timestamp, dont interpolate
                    *curr_ld_buf = (U32)(((float)divisor_s16 / scaler_s16) * *curr_data * pow(10, base10_shift_s16));

                    curr_ld_buf++;
                    rolling_ts += min_time_delta;
                }
            }
            else
            {
                // in the middle of the data, keep moving until the ts before is less and
                // the ts after is greater. We should never move beyond the last ts.

                while (rolling_ts > *(curr_ts + 1))
                {
                    curr_ts++;
                    curr_data++;
                }

                // interpolate the data between the point before and point after
                U32 time_dist_tot = *(curr_ts + 1) - *curr_ts;
                float interp_data = (*(curr_data + 1) * (rolling_ts - *curr_ts)) +
                                     (*curr_data * (*(curr_ts + 1) - rolling_ts));
                interp_data /= time_dist_tot;

                *curr_ld_buf = (U32)(((float)divisor_s16 / scaler_s16) * interp_data * pow(10, base10_shift_s16));

                curr_ld_buf++;
                rolling_ts += min_time_delta;
            }
        }

        // get the rest of the channel metadata from the GCAN param data
        sprintf(chan_name, "%s", name_strings[curr_gdat->channel.gcan_id]);
        sprintf(name_shrt, "gcan%u", curr_gdat->channel.gcan_id);
        sprintf(chan_unit, "%s", unit_strings[curr_gdat->channel.gcan_id]);

        // create the ld channel!
        if (add_channel_to_list(ld_head, ld_data_points, ld_buf, frequency_hz, offset_s16, scaler_s16,
                                divisor_s16, base10_shift_s16, chan_name, name_shrt, chan_unit)) return -1;

        // print the stats about the channel if needed
        if (print_chan_stats)
        {
            printf("CHANNEL ID: %u\n", curr_gdat->channel.gcan_id);
            printf("\tdata max: %f\n", data_max);
            printf("\tdata min: %f\n", data_min);
            printf("\tmax time: %u\n", max_time);
            printf("\tdelta_t max (ms): %u\n", max_time_delta);
            printf("\tdelta_t mix (ms): %u\n", min_time_delta);
            printf("\toffset: %d\n", offset_s16);
            printf("\tscaler: %d\n", scaler_s16);
            printf("\tdivisor: %d\n", divisor_s16);
            printf("\tbase10: %d\n", base10_shift_s16);
            printf("\tld data points: %u\n", ld_data_points);
            printf("\tname: %s\n", chan_name);
            printf("\tshort name: %s\n", name_shrt);
            printf("\tunit: %s\n", chan_unit);
        }

        curr_gdat = curr_gdat->next;
    }

    return 0;
}


// cutoff_string
//  add a null char to the first non-letter/number character in the string
void cutoff_string(char* str, U32 length)
{
    char* temp_char = str;

    // space is the lowest acceptable char, ~ is the highets
    while((temp_char - str < length) && *temp_char >= ' ' && *temp_char <= '~')
    {
        temp_char++;
    }
    *temp_char = '\0';
}


// convert_float_to_frac
//  Convert a floating point number to a numerator and denomerator. returning
//  the error in the final meaurment. Returning -1.0 means the algorithm failed
double convert_float_to_frac(double dlb, S16* num, S16* den)
{
    double error;

    long m[2][2];
    double x, startx;
    long maxden;
    long ai;

    startx = x = dlb;
    maxden = INT16_MAX;

    // initialize matrix
    m[0][0] = m[1][1] = 1;
    m[0][1] = m[1][0] = 0;

    // loop finding terms until denom gets too big
    while (m[1][0] * ( ai = (long)x ) + m[1][1] <= maxden)
    {
        long t;
        t = m[0][0] * ai + m[0][1];
        m[0][1] = m[0][0];
        m[0][0] = t;
        t = m[1][0] * ai + m[1][1];
        m[1][1] = m[1][0];
        m[1][0] = t;
        if(x==(double)ai) break;     // AF: division by zero
        x = 1/(x - (double) ai);
        if(x>(double)0x7FFFFFFF) break;  // AF: representation failure
    } 

    // now remaining x is between 0 and 1/ai
    // approx as either 0 or 1/m where m is max that will fit in maxden
    // first try zero
    error = startx - ((double) m[0][0] / (double) m[1][0]);

    // now try other possibility
    ai = (maxden - m[1][1]) / m[1][0];
    m[0][0] = m[0][0] * ai + m[0][1];
    m[1][0] = m[1][0] * ai + m[1][1];
    error = startx - ((double) m[0][0] / (double) m[1][0]);

    *num = (S16)m[0][0];
    *den = (S16)m[1][0];

    return error;
}